[toc]



# Redis持久化



##### 简介

redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。

#### 持久化流程

（1）客户端向服务端发送写操作(数据在客户端的内存中)。

（2）数据库服务端接收到写请求的数据(数据在服务端的内存中)。

（3）服务端调用write这个系统调用，将数据往磁盘上写(数据在系统内存的缓冲区中)。

（4）操作系统将缓冲区中的数据转移到磁盘控制器上(数据在磁盘缓存中)。

（5）磁盘控制器将数据写到磁盘的物理介质中(数据真正落到磁盘上)。



#### redis持久化机制

安装了redis之后，所有的配置都是在redis.conf文件中，里面保存了RDB和AOF两种持久化机制的各种配置。

##### 1.RDB(Redis DataBase)

把数据以快照的形式保存在磁盘上。

这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。

###### （1）RDB的三种机制：

1） save 触发方式(手动执行)

- 该命令会堵塞当前redis 服务器，执行期间不能执行其他命令，直到save完成。
- 执行完成会替换掉之前save的文件。

2)   bgsave触发方式(手动执行)

- Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。

- ==具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。==阻塞只发生在fork阶段，一般时间很短。基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。

3)   自动触发

```shell
# redis.conf 中,有如下配置，用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。
# save：
save 900 1	# （900秒持久化一次，1个key发生改变）
save 300 10 # （300秒持久化一次，10个key发生改变）
save 60 10000 # （60秒持久化一次，10000个key发生改变）

# 如果不需要持久化，可以注释掉所有的 save 行来停用保存功能。

==========================================
# 其他配置

stop-writes-on-bgsave-error ：默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了

rdbcompression ；默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。

rdbchecksum ：默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。

dbfilename ：设置快照的文件名，默认是 dump.rdb

dir：设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。
```

###### （2）重启生效

```shell
# 重新启动redis服务器，并指定配置文件名称
        
 D:\\redis-2.8.9>redis-server.exe redis.windows.conf	
```

###### （3）优劣

**优势**

- （1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。
- （2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。
- （3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。

**劣势**

- RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。



##### 2. AOF(Append Only File)

> （1）日志记录的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文
>
> （2）bgrewriteaof 命令：持久化文件会变的越来越大。为了压缩aof的持久化文件。redis提供了bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会fork出一条新进程来将文件重写。==重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件==



###### AOF三种触发机制

> （1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好
>
> （2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失
>
> （3）不同no：从不同步

```shell
	# 编辑redis.windwos.conf文件
	appendonly no（关闭aof） --> appendonly yes （开启aof）

	# appendfsync always ： 每一次操作都进行持久化
		appendfsync everysec ： 每隔一秒进行一次持久化
	# appendfsync no	 ： 不进行持久化
```

###### 优劣

**优点**

> （1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。
>
> （2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。
>
> （3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。
>
> （4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据

**缺点**

>（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大
>
>（2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的
>
>（3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。



### Redis 缓存雪崩

###### 情形

redis缓存的使用一般是直接查询缓存，如果缓存没有，则查询数据库，同时把数据放到缓存中。

redis key设置有失效时间，假如失效时间都设置为00：00，在00：00有大量请求的时候，key都失效了，接着大量请求就会访问数据库，数据库很可能短时间内扛不住挂掉。

###### 解决

- 1.将数据部分数据设置为永不过期，当在修改删除时同时更新缓存。`redisUtils.set("111","111",-1);`
- 2.将数据失效时间设置成随机时间，这样不会大量数据同时失效。
- 3.集群部署。----



### Redis 缓存穿透

###### 情形

查询一条不存在的数据，redis没有，数据库也没有，如果大量的这种请求同时访问数据库，数据库也有扛不住炸掉。

###### 解决

- 尽量对查询进行校验，不让这种垃圾请求去访问数据库（如添加登录校验，添加参数校验），直接return。
- 将不存在的key短时间设置为null，可以为30秒，这样下一次就直接返回null，不会访问数据库了
- 布隆过滤器（可以判断key是否存在）

```shell
=========================
# 布隆过滤器：一种数据结构，是由一串很长的二进制向量组成，可以将其看成一个二进制数组。
# 初始都是0
00000000000000000000000000000000000000
# 要添加一个key的时候，通过多种hash计算得出一个值，并把该位置的值改为1
00000000000000000000000000010000000000
# 判断是否存在的时候，如果key计算的结果查出来是1，那么便可能存在，是0则一定不存在

==========================
优点：优点很明显，二进制组成的数组，占用内存极少，并且插入和查询速度都足够快。
缺点：随着数据的增加，误判率会增加；还有无法判断数据一定存在；另外还有一个重要缺点，无法删除数据。
```



### Redis 缓存击穿

###### 情形

假如一个key正在高频使用，突然失效了，这样大量请求也会冲进数据库，给数据库巨大压力。

###### 解决

1. 互斥锁

- 当缓存失效的时候，不是直接查询数据库，先根据key创建一个redis键值对（锁）过期时间很短，然后再查询数据库，放到缓存中
- 后面查询的时候，redis查不到会进入判断锁的阶段，有锁则线程休眠，之后再次查询redis。

2. redis查不到指定key的时候，先创建一个锁，然后sql查询。后来的请求查不到值但查到了锁，返回刷新之类的提示。

```java
    public Object sss(String key) {
        Object sss = redisUtils.get(key);
        if (sss == null){
            if (redisUtils.getLock(key)){
                // 查询数据库
                //释放锁
                redisUtils.delete(key);
            }else {
                try {
                    Thread.sleep(50L);
                    // 重新调用此方法
                    return sss(key);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        return sss;
    }
```



### Redis分布式锁

```java
// setIfAbsent,如果为空就set值，返回1
//				不为空则不进行操作，返回0

public boolean getLock(String lockId, long millisecond){
   String requestId = UUID.randomUUID().toString();
   Boolean look = redisTemplate.opsForValue().setIfAbsent(lockId, requestId, millisecond, TimeUnit.MILLISECONDS);
   if(look){
      //设置过期时长
      redisTemplate.expire(lockId,RedisUtils.CAPTCH, TimeUnit.SECONDS);
   }
   return look != null && look;
}

// 
public void delete(String key) {
    redisTemplate.delete(key);
}
```

**同时设置锁的key+value和time**

```shell
# SETEX key value	time

SETEX user wangwang 1000

# SETEX 是一个原子性(atomic)操作，关联值和设置生存时间两个动作会在同一时间内完成,这样就可以解决在分布式锁设置过期时间之前服务停止，而导致死锁的问题。
```

